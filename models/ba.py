# -*- coding: utf-8 -*-
"""BA 랜덤 네트워크 모델 클래스 구현.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wVxvAaitzyHPdwnig8cpf2Mhb5n4xymZ
"""

class BA:
    def __init__(self, G, n, m=None, m0=5, seed=None):

        self.G = G
        self.num_simulations = n
        self.m0 = m0
        self.seed = seed

        # [예외처리 추가]
        # if not isinstance(self.G, nx.Graph):
        #     raise TypeError("G must be a networkx.Graph.")
        if not isinstance(self.num_simulations, int) or self.num_simulations < 1:
            raise ValueError("n must be a positive int.")
        if not isinstance(self.m0, int) or self.m0 < 2:
            raise ValueError("m0 must be an integer >= 2.")

        if self.seed is not None:
            if not isinstance(self.seed, int):
                raise TypeError("seed must be int or None.")
            random.seed(self.seed)

        # 원본 네트워크 크기/엣지 수/차수
        self.n_total = self.G.number_of_nodes()
        self.m_edges = self.G.number_of_edges()
        self.degree_seq = [d for _, d in self.G.degree()]

        # m이 주어지지 않으면 평균차수(<k>)≈2m 관계로부터 추정: m ≈ round(<k>/2)
        if m is None:
            avg_deg = (2.0 * self.m_edges / self.n_total) if self.n_total > 0 else 0.0
            self.m_attach = max(1, int(round(avg_deg / 2.0)))
        else:
            self.m_attach = m

        # [예외처리 추가] BA 제약 확인: n_total >= m0, m >= 1, m0 >= m+1
        if self.n_total < self.m0:
            raise ValueError("n_total must be >= m0.")
        if not isinstance(self.m_attach, int) or self.m_attach < 1:
            raise ValueError("m must be an integer >= 1.")
        if self.m0 < self.m_attach + 1:
            raise ValueError("m0 must be >= m+1 for reliable selection of m distinct targets.")

        print("original network 노드 개수 :", self.n_total, "엣지 개수", self.m_edges)
        print(f"BA 파라미터: n_total={self.n_total}, m={self.m_attach}, m0={self.m0}")

        # 결과 저장
        self.ba_models = []
        self.original_degree_dist = None
        self.ba_degree_dists = []

    # ----- (2) 선호적 연결대상 선택 함수 -----
    def choose_target_node(self, existing_nodes, G):
        degrees = [G.degree(n) for n in existing_nodes]
        total_degree = sum(degrees)

        # 차수 합이 0이면 무작위 선택
        if total_degree == 0:
            return random.choice(existing_nodes)

        # p_i = k_i / sum k_j
        probs = [deg / float(total_degree) for deg in degrees]

        # 축적 확률 사용
        total = sum(probs)
        cumulative_weights = []
        cum_sum = 0.0
        for w in probs:
            cum_sum += w
            cumulative_weights.append(cum_sum)

        r = random.uniform(0.0, total)
        for i, cw in enumerate(cumulative_weights):
            if r <= cw:
                return existing_nodes[i]

        # 안전장치
        return existing_nodes[-1]

    # ----- BA 한 번 생성  -----
    def ba_random_graph(self, n_total, m, m0):

        # [예외처리 추가]
        if not (isinstance(n_total, int) and isinstance(m, int) and isinstance(m0, int)):
            raise TypeError("n_total, m, m0 must be int.")
        if n_total < 2:
            raise ValueError("n_total must be >= 2.")
        if m < 1:
            raise ValueError("m must be >= 1.")
        if m0 < 2:
            raise ValueError("m0 must be >= 2.")
        if n_total < m0:
            raise ValueError("n_total must be >= m0.")
        if m0 < m + 1:
            raise ValueError("m0 must be >= m+1.")

        G = nx.Graph()

        # (1) 초기 노드 m0개 생성 + 완전그래프
        for i in range(m0):
            G.add_node(i)
        for i in range(m0):
            for j in range(i + 1, m0):
                G.add_edge(i, j)

        # (3) 새 노드 추가
        next_node = m0
        while next_node < n_total:
            targets = set()
            while len(targets) < m:
                chosen = self.choose_target_node(list(G.nodes), G)
                # 중복/자기루프 방지
                if chosen not in targets and chosen != next_node:
                    targets.add(chosen)

            # 새 노드 연결
            G.add_node(next_node)
            for t in targets:
                G.add_edge(next_node, t)
            next_node += 1

        # [예외처리 추가] self-loop 안전 점검
        assert not nx.number_of_selfloops(G), "Self-loop detected unexpectedly."
        return G

    # ----- 반복 생성 -----
    def n_repeat(self):
        self.ba_models = []
        for _ in range(self.num_simulations):
            temp_net = self.ba_random_graph(self.n_total, self.m_attach, self.m0)
            self.ba_models.append(nx.Graph(temp_net))
        print("BA 모델 반복 생성 완료")
        return self.ba_models

    # ----- 분포 계산 -----
    def cal_dist(self):
        if len(self.degree_seq) == 0:
            raise ValueError("원본 네트워크 degree 시퀀스가 비어 있습니다.")

        bins_range = range(max(self.degree_seq) + 2)
        self.original_degree_dist = np.histogram(
            self.degree_seq, bins=bins_range, density=True
        )[0]

        self.ba_degree_dists = []
        for g in self.ba_models:
            degs = [d for _, d in g.degree()]
            dist = np.histogram(degs, bins=bins_range, density=True)[0]
            self.ba_degree_dists.append(dist)

        print("dist 계산 완료")

    # --- histogram ---
    def draw_histogram(self):
      fig, ax = plt.subplots(1, 1, figsize = (8, 5))

      ax.bar(range(len(self.original_degree_dist)), self.original_degree_dist, alpha = 0.7, color = 'blue', label='Uganda Network', width = 0.4, align = 'center')

      mean_dist = np.mean(self.ba_degree_dists, axis = 0)
      ax.bar(np.arange(len(self.original_degree_dist))+0.4, mean_dist, alpha = 0.7, color = '#E6B8AF', label='BA Model', width = 0.4, align = 'center')

      ax.set_xlabel(r'degree($k$)', fontsize=15)
      ax.set_ylabel(r'$P(k)$', fontsize = 15)

      plt.legend(fontsize=12)
      plt.show()

    # 파워로 피팅으로 beta(베타) 찾기
    def fit_beta(self, sample_graph=None, kmin=3):
        import numpy as np
        from scipy.optimize import curve_fit
        import matplotlib.pyplot as plt

        # BA로 생성된 첫 번째 그래프 사용
        if sample_graph is None:
            if len(self.ba_models) == 0:
                raise ValueError("먼저 n_repeat()로 BA 모델을 생성하세요.")
            G = self.ba_models[0]
        else:
            G = sample_graph

        # === degree 분포 계산 ===
        degrees = [G.degree(n) for n in G.nodes()]
        k_vals = sorted(set(degrees))
        p_vals = [degrees.count(k) / len(degrees) for k in k_vals]

        # array로 변환
        k_vals = np.array(k_vals, dtype=float)
        p_vals = np.array(p_vals, dtype=float)

        # ===  낮은 k 제외  ===
        mask = (k_vals >= kmin) & (p_vals > 0)
        k_fit = k_vals[mask]
        p_fit = p_vals[mask]

        # 파워로 모델 정의
        def power_law(x, a, b):
            return a * x ** (-b)

        # === curve_fit  ===
        popt, _ = curve_fit(power_law, k_fit, p_fit, maxfev=20000)
        a_hat, b_hat = popt

        # === 로그-로그 그림 ===
        plt.figure(figsize=(8, 5))
        plt.scatter(k_vals, p_vals, label="Degree distribution", color='skyblue')

        kk = np.linspace(k_vals.min(), k_vals.max(), 200)
        plt.plot(kk, power_law(kk, a_hat, b_hat), 'r--',
                 label=f"Fit: a·k^(-b), b ≈ {b_hat:.2f}")

        plt.xscale('log')
        plt.yscale('log')
        plt.xlabel("Degree k (log)")
        plt.ylabel("P(k) (log)")
        plt.title("BA Model Degree Distribution (Log-Log Scale)")
        plt.legend()
        plt.tight_layout()
        plt.show()

        return a_hat, b_hat



