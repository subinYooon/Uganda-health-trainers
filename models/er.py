# -*- coding: utf-8 -*-
"""ER 랜덤 네트워크 모델 클래스 구현.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e7HUWBXj3U-3fYsFW5Jxtg91VXmrGjRD
"""

class ER:
    def __init__(self, G, n, mode="gnp"):
        self.G = G
        self.num_simulations = n
        self.mode = mode  # "gnp" or "gnm"

        # [예외처리 추가]
        # if not isinstance(self.G, nx.Graph):
        #     raise TypeError("G must be a networkx.Graph.")
        if self.mode not in ("gnp", "gnm"):
            raise ValueError('mode must be "gnp" or "gnm".')
        if not isinstance(self.num_simulations, int) or self.num_simulations < 1:
            raise ValueError("n must be a positive int.")

        self.n = self.G.number_of_nodes()
        self.m = self.G.number_of_edges()
        self.G_degree = self.G.degree()
        self.degree_seq = [d for _, d in self.G_degree]

        print("original network 노드 개수 :", self.n, "엣지 개수", self.m)

        self.er_models = []
        self.original_degree_dist = None
        self.er_degree_dists = []

    # ----- G(n,p) -----
    def gnp_random_graph(self, N, p):
        # [예외처리 추가]
        if not isinstance(N, int):
            raise TypeError("N must be int.")
        if N < 1:
            raise ValueError("N must be >= 1.")
        if not isinstance(p, (int, float)):
            raise TypeError("p must be a number.")
        if not (0.0 <= p <= 1.0):
            raise ValueError("p must be between 0 and 1.")

        G = nx.Graph()
        G.add_nodes_from(range(N))

        for i, j in itertools.combinations(G.nodes, 2):
            r = random.random()  # 0~1 난수 생성
            if r < p:            # 확률 p보다 작으면
                G.add_edge(i, j) # 엣지 추가
            # r >= p 이면 아무것도 안 함

        # [예외처리 추가] self-loop 안전 점검(설계상 없어야 함)
        assert not nx.number_of_selfloops(G), "Self-loop detected unexpectedly."
        return G

    # ----- G(n,M) -----
    def gnm_random_graph(self, N, M):
        # [예외처리 추가]
        if not isinstance(N, int) or not isinstance(M, int):
            raise TypeError("N and M must be int.")
        if N < 1:
            raise ValueError("N must be >= 1.")
        max_edges = N * (N - 1) // 2
        if not (0 <= M <= max_edges):
            raise ValueError(f"M must be in [0, {max_edges}] for N={N}.")

        G = nx.Graph()
        G.add_nodes_from(range(N))

        possible_edges = list(itertools.combinations(G.nodes, 2))
        edges_to_add = random.sample(possible_edges, M)
        G.add_edges_from(edges_to_add)

        # [예외처리 추가]
        assert not nx.number_of_selfloops(G), "Self-loop detected unexpectedly."
        return G

    # ----- 반복 생성 -----
    def n_repeat(self):
        if self.n < 2:
            raise ValueError("원본 그래프의 노드 수가 2 미만입니다.")

        self.er_models = []

        if self.mode == "gnp":
            # 원본 밀도로 p 설정: p = 2m / (n(n-1))
            denom = self.n * (self.n - 1)
            if denom == 0:
                raise ValueError("n is too small to estimate p.")
            p = (2.0 * self.m) / float(denom)
            # [예외처리 추가] p 범위 보정
            p = max(0.0, min(1.0, p))

            for _ in range(self.num_simulations):
                temp_net = self.gnp_random_graph(self.n, p)
                self.er_models.append(nx.Graph(temp_net))

        else:  # "gnm"
            M = self.m
            for _ in range(self.num_simulations):
                temp_net = self.gnm_random_graph(self.n, M)
                self.er_models.append(nx.Graph(temp_net))

        print("ER 모델 반복 생성 완료")
        return self.er_models

    # ----- 분포 계산 -----
    def cal_dist(self):
        if len(self.degree_seq) == 0:
            raise ValueError("원본 네트워크 degree 시퀀스가 비어 있습니다.")

        bins_range = range(max(self.degree_seq) + 2)
        self.original_degree_dist = np.histogram(
            self.degree_seq, bins=bins_range, density=True
        )[0]

        self.er_degree_dists = []
        for g in self.er_models:
            degs = [d for _, d in g.degree()]
            dist = np.histogram(degs, bins=bins_range, density=True)[0]
            self.er_degree_dists.append(dist)

        print("dist 계산 완료")

    # --- histogram ---
    def draw_histogram(self):
      fig, ax = plt.subplots(1, 1, figsize = (8, 5))

      ax.bar(range(len(self.original_degree_dist)), self.original_degree_dist, alpha = 0.7, color = 'blue', label='Uganda Network', width = 0.4, align = 'center')

      mean_dist = np.mean(self.er_degree_dists, axis = 0)
      ax.bar(np.arange(len(self.original_degree_dist))+0.4, mean_dist, alpha = 0.7, color = '#E6B8AF', label='ER Model', width = 0.4, align = 'center')

      ax.set_xlabel(r'degree($k$)', fontsize=15)
      ax.set_ylabel(r'$P(k)$', fontsize = 15)

      plt.legend(fontsize=12)
      plt.show()
