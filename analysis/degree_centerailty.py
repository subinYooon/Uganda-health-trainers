# -*- coding: utf-8 -*-
"""중심성_지표_비교_degree_centerailty.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17AMPeysZlMG5t02TznRTTTDDEkvnRufc
"""

# module import
import networkx as nx
import itertools
import pandas as pd
import random
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns



# 원본 그래프 불러오기
csv_file = '/content/uganda health data'
df = pd.read_csv(csv_file, header=None)

G = nx.Graph()
G.add_nodes_from(set(list(df.iloc[:, 0]) + list(df.iloc[:, 1])))

for i in range(len(df)):
  if df.iloc[i, 1] != df.iloc[i, 0]:
    G.add_edge(df.iloc[i, 0], df.iloc[i, 1])

print(len(G.nodes()), len(G.edges()))

degree_sequence = [i for _,i in G.degree()]

"""# 랜덤 그래프 생성"""

# chung-lu graph
def create_chung_lu_graph(G):

  degrees = [d for _,d in G.degree()]

  total_degree = sum(degrees)
  n = len(degrees)

  new_G = nx.Graph()
  new_G.add_nodes_from(range(n))

  for i in range(n) :
      for j in range(i+1,n) :
          p_ij = degrees[i] * degrees[j] / total_degree
          p_ij = min(1.0, p_ij)

          if random.random() < p_ij :
              new_G.add_edge(i, j)
  return new_G

# ER graph
# --- 1. G(n, p) 무작위 그래프 생성 함수 ---
def gnp_random_graph(N, p):

    G = nx.Graph()
    G.add_nodes_from(range(N))

    for i, j in itertools.combinations(G.nodes, 2):
        r = random.random()  # 0~1 난수 생성
        if r < p:            # 확률 p보다 작으면
            G.add_edge(i, j) # 엣지 추가

    # self-loop 안전 점검(설계상 없어야 함)
    assert not nx.number_of_selfloops(G), "Self-loop detected unexpectedly."
    return G

# config model, function

def create_config_graph(degree_seq) :
  stub_list = []
  for node,degree in enumerate(degree_seq) :
    stub_list.extend([node]*degree) # extend?

  # shuffle
  random.shuffle(stub_list)

  config_graph = nx.Graph()
  config_graph.add_nodes_from(range(len(degree_seq)))

  # 리스트 안의 노드 수가 1개 초과일 때
  while len(stub_list) > 1:
    # 노드 두개를 뽑아옴
    node1 = stub_list.pop()
    node2 = stub_list.pop()

    while node1 == node2 and len(stub_list) > 0 :
      stub_list.append(node2)
      random.shuffle(stub_list)
      node2 = stub_list.pop()
    if node1!=node2 :
      config_graph.add_edge(node1,node2)

  return config_graph

# 원본 그래프 기반 랜덤 그래프 생성
N = len(G.nodes())

cl_G = create_chung_lu_graph(G)
ER_G = gnp_random_graph(N,0.3)
cc_G = create_config_graph(degree_sequence)

"""# 박스플랏"""

import networkx as nx
import matplotlib.pyplot as plt
import pandas as pd
# import seaborn as sns # 불필요한 라이브러리는 제거합니다.

# -----------------------------
# 공통 스타일 박스플롯 (degree 전용)
# -----------------------------
def plot_degree_boxplot(values_list, labels, ylim=None, savepath=None):

    colors = ["#6baed6", "#9ecae1", "#c7e9b4", "#fdd0a2"]  # 부드러운 4색 팔레트

    plt.figure(figsize=(10, 6))
    bp = plt.boxplot(
        values_list,
        labels=labels,
        patch_artist=True,
        showfliers=False,
        widths=0.6
    )

    # 박스 색상 + 라인 통일
    for patch, color in zip(bp['boxes'], colors):
        patch.set_facecolor(color)
        patch.set_edgecolor("#4c4c4c")
        patch.set_linewidth(1.2)

    for median in bp['medians']:
        median.set_color("#d62728")
        median.set_linewidth(2.2)

    for whisker in bp['whiskers']:
        whisker.set_color("#4c4c4c")
        whisker.set_linewidth(1.2)

    for cap in bp['caps']:
        cap.set_color("#4c4c4c")
        cap.set_linewidth(1.2)

    # ---- 라벨 크게 ----
    plt.xlabel("Network Model", fontsize=15)
    plt.ylabel("Degree Centrality", fontsize=17)
    plt.xticks(fontsize=14)
    plt.yticks(fontsize=13)

    if ylim:
        plt.ylim(*ylim)

    plt.grid(axis='y', linestyle='--', alpha=0.6)
    plt.tight_layout()

    if savepath:
        plt.savefig(savepath, dpi=300)
        plt.close()
    else:
        plt.show()

# -----------------------------
# degree 중앙성 계산 + 플롯
# -----------------------------
def boxplot_degree_same_style(G_actual, G_er, G_config, G_cl, savepath=None):

    # 1. degree Centrality 계산
    # get_degree 함수는 제거하고, nx.degree_centrality를 직접 사용합니다.
    # .values()를 사용하여 중앙성 값 리스트만 추출합니다.
    d_actual = list(nx.degree_centrality(G_actual).values())
    d_er     = list(nx.degree_centrality(G_er).values())
    d_config = list(nx.degree_centrality(G_config).values())
    d_cl     = list(nx.degree_centrality(G_cl).values())

    values_list = [d_actual, d_er, d_config, d_cl]
    labels = ["Original", "ER", "Config", "Chung-Lu"]

    # 2. 플롯 함수 호출 (ylim은 degree 값에 맞게 조정이 필요할 수 있습니다.)
    # 기존 closeness 예시의 (0.2, 0.65) 대신 None을 기본으로 사용하여 자동 범위를 사용하거나,
    # 필요에 따라 적절한 범위를 설정할 수 있습니다.
    plot_degree_boxplot(
        values_list,
        labels,
        ylim=None, # 예: (0, 0.05)와 같이 조정 가능
        savepath=savepath
    )

# 사용 예시 (주석 처리됨)
import networkx as nx
G_actual = G

N = len(G.nodes())

G_cl = create_chung_lu_graph(G)
G_er = gnp_random_graph(N,0.3)
G_config = create_config_graph(degree_sequence)


boxplot_degree_same_style(G_actual, G_er, G_config, G_cl, "degree_boxplot.png")

